import java.util.ArrayList;
import java.util.List;
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.geom.*;

public class Cube {

    Vertex[] vList;
    List<Face> faces = new ArrayList<Face>();
    Matrix3D transform;
    int vertQuant;
    
    public Cube(Vertex[] vListIn) {
	vList = vListIn;
	transform = new Matrix3D();
    }

    public void setFace(int[] vertices) {
	//first to second, first to lastvdot product 
	Face tempFace = new Face(vertices);
	faces.add(tempFace);
    }

    public void setVertQuant(int a) {
	vertQuant = a;
    }

    public void scale(double a){
	transform.scale(a);
    }
    //rotate counter clockwise looking down specified axis
    //axis is a string, either "x", "y", or "z"
    public void rotate(double degree, String axis){
	transform.rotate(degree, axis);
    }

    public void arbitratyRotate(double degree, Vector v) {
	v.normalize();
	double a = v.getX();
	double b = v.getY();
	double c = -v.getZ();
	double d = Math.sqrt(Math.pow(b,2)+Math.pow(c,2));
	Matrix3D tran = new Matrix3D();
	if (d == 0) {
	    double[][] matrix = {{d,0,-a},{0,1,0},{a,0,d}};
	    tran.setValues(matrix);
	    transform.concat(tran);
	    matrix = new double[][] {{Math.cos(degree),-Math.sin(degree),0},{Math.sin(degree),Math.cos(degree),0},{0,0,1}};
	    tran.setValues(matrix);
	    transform.concat(tran);
	    matrix = new double[][] {{d,0,a},{0,1,0},{-a,0,d}};
	    tran.setValues(matrix);
	    transform.concat(tran);
	}
	else{
	    double[][] matrix = {{1,0,0},{0,c/d,-b/d},{0,b/d,c/d}};
	    tran.setValues(matrix);
	    transform.concat(tran);
	    matrix = new double[][] {{d,0,-a},{0,1,0},{a,0,d}};
	    tran.setValues(matrix);
	    transform.concat(tran);
	    matrix = new double[][] {{Math.cos(degree),-Math.sin(degree),0},{Math.sin(degree),Math.cos(degree),0},{0,0,1}};
	    tran.setValues(matrix);
	    transform.concat(tran);
	    matrix = new double[][] {{d,0,a},{0,1,0},{-a,0,d}};
	    tran.setValues(matrix);
	    transform.concat(tran);
	    matrix = new double[][] {{1,0,0},{0,c/d,b/d},{0,-b/d,c/d}};
	    tran.setValues(matrix);
	    transform.concat(tran);
	}
    }

    //project shapes onto screen which is "distance" away from the eye
    public void surface(Graphics2D g, int distance) {
	Vertex[] tVertices = new Vertex[vList.length];
	for(int i=0;i<vList.length;i++) {
	     tVertices[i]= transform.mult(vList[i]);
	}
	for(Face f : faces) {
	    if(isVisible(f,tVertices,distance) == true){
		perspective(g,f,tVertices,distance, true);
	    }
	}
    }

    public boolean isVisible(Face f, Vertex[] v, int distance) {
	Vector v1 = v[f.getIndex(1)].sub(v[f.getIndex(0)]);
	Vector v2 = v[f.getIndex(f.size()-1)].sub(v[f.getIndex(0)]);
	Vector eye = v[f.getIndex(0)].sub(new Vertex(0,0,distance));
	
	if (eye.dot(v1.cross(v2)) < 0) {
	    return true;
	}
	return false;
    }

    public void wireFrame(Graphics2D g, int distance) {
	Vertex[] tVertices = new Vertex[vList.length];
	for(int i=0;i<vList.length;i++) {
	     tVertices[i]= transform.mult(vList[i]);
	}
	for(Face f : faces) {
	    perspective(g,f,tVertices,distance, false);
	}
    }

    public void perspective(Graphics2D g, Face f, Vertex[] tVertices, int distance, boolean surface) {
	Path2D.Double path = new Path2D.Double();;
	boolean flag = true;
	double x;
	double y;
	for(int i=0;i<f.size();i++) {
	    x = tVertices[f.getIndex(i)].getX()*distance/(distance-tVertices[f.getIndex(i)].getZ());
	    y = tVertices[f.getIndex(i)].getY()*distance/(distance-tVertices[f.getIndex(i)].getZ());
	    if (flag == true) {
		path.moveTo(x,y);
		flag = false;
	    }
	    else{
		path.lineTo(x,y);
	    }
	}
	x = tVertices[f.getIndex(0)].getX()*distance/(distance-tVertices[f.getIndex(0)].getZ());
	y = tVertices[f.getIndex(0)].getY()*distance/(distance-tVertices[f.getIndex(0)].getZ());
	path.lineTo(x,y);
	if (surface == true) {
	    g.setPaint(f.getColor());
	    g.fill(path);
	}
	else {
	    g.setPaint(Color.black);
	    g.draw(path);
	}
    }
}
